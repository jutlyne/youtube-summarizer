<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>T√≥m T·∫Øt Video YouTube B·∫±ng AI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.2/marked.min.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <h1>ü§ñ T√≥m T·∫Øt Video YouTube B·∫±ng AI</h1>
      <p>Nh·∫≠p URL YouTube v√† nh·∫≠n b·∫£n t√≥m t·∫Øt chi ti·∫øt t·ª´ Gemini.</p>

      <form id="summaryForm">
        <div class="input-group">
          <label for="youtubeUrl">URL YouTube:</label>
          <input
            type="url"
            id="youtubeUrl"
            placeholder="V√≠ d·ª•: https://youtu.be/..."
            required
          />
        </div>
        <button type="submit" id="submitBtn">T√≥m T·∫Øt</button>
      </form>

      <div id="loadingMessage" class="hidden">
        <div class="spinner"></div>
        ƒêang x·ª≠ l√Ω... (Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t v√†i ph√∫t.)
      </div>

      <div id="results" class="hidden">
        <h2>üìù K·∫øt Qu·∫£ T√≥m T·∫Øt</h2>
        <button id="readSummaryBtn" onclick="readSummary()">
          üîä ƒê·ªçc T√≥m T·∫Øt
        </button>
        <div id="summaryText"></div>
      </div>

      <div id="errorMessage" class="error hidden"></div>
    </div>

    <script>
      let audioPlayer = null;

      function getStatusMessage(status, jobId) {
        let message = 'ƒêang x·ª≠ l√Ω...';
        switch (status) {
          case 'PENDING':
            message = 'ƒêang ch·ªù kh·ªüi t·∫°o c√¥ng vi·ªác...';
            break;
          case 'STREAMING':
            message =
              'ƒêang t·∫£i v√† truy·ªÅn t·∫£i audio l√™n Google Cloud Storage...';
            break;
          case 'TRANSCRIBING':
            message =
              'ƒêang chuy·ªÉn ƒë·ªïi gi·ªçng n√≥i th√†nh vƒÉn b·∫£n (Speech-to-Text). Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t v√†i ph√∫t cho video d√†i.';
            break;
          case 'SUMMARIZING':
            message =
              'ƒêang g·ª≠i vƒÉn b·∫£n cho Gemini ƒë·ªÉ t√≥m t·∫Øt v√† ph√¢n ƒëo·∫°n n·ªôi dung...';
            break;
          case 'COMPLETED':
            message = 'Ho√†n th√†nh.';
            break;
          case 'FAILED':
            message = 'Th·∫•t b·∫°i.';
            break;
          default:
            message = `ƒêang x·ª≠ l√Ω (${status})...`;
        }

        const loadingMessageBase = `
            <div class="spinner"></div> 
            <strong>${message}</strong> 
            <br>
            Job ID: ${jobId}
        `;

        return {
          button: `ƒêang x·ª≠ l√Ω (${status})...`,
          loading: loadingMessageBase,
        };
      }

      function convertTimestampsToLinks(summaryText, youtubeUrl) {
        const rangeRegex = /\[(\d{1,2}):(\d{2})[‚Äì-](\d{1,2}):(\d{2})\]/g;
        const complexRangeRegex = /\[([^\]]*\d{1,2}:\d{2}[^\]]*)\]/g;

        let videoId = '';
        try {
          const urlObj = new URL(youtubeUrl);
          videoId = urlObj.searchParams.get('v');
          if (!videoId) {
            videoId = urlObj.pathname.substring(1);
          }
        } catch (e) {
          return summaryText;
        }

        if (!videoId) {
          return summaryText;
        }

        const createLink = (minutes, seconds) => {
          const startSeconds = parseInt(minutes) * 60 + parseInt(seconds);
          const timeString = `${minutes}:${seconds}`;
          const linkUrl = `https://www.youtube.com/watch?v=${videoId}&amp;t=${startSeconds}s`;
          return `<a href="${linkUrl}" target="_blank" class="timestamp-link">${timeString}</a>`;
        };

        let preprocessedSummary = summaryText.replace(
          complexRangeRegex,
          (match, content) => {
            let parts = content.split(/,\s*|,\s*(\d{1,2}:\d{2})/);
            parts = parts.filter((p) => p && p.trim().length > 0);

            const reformatted = parts.map((p) => `[${p.trim()}]`).join(' ');

            return reformatted;
          }
        );

        let linkedSummary = preprocessedSummary.replace(
          rangeRegex,
          (match, m1, s1, m2, s2) => {
            const startLink = createLink(m1, s1);
            const endLink = createLink(m2, s2);

            return `[${startLink}]‚Äì[${endLink}]`;
          }
        );

        const singleRegex = /\[(\d{1,2}):(\d{2})\]/g;

        const finalSummary = linkedSummary.replace(
          singleRegex,
          (match, minutes, seconds) => {
            const singleLink = createLink(minutes, seconds);

            return `[${singleLink}]`;
          }
        );

        return finalSummary;
      }

      async function readSummary() {
        const btn = document.getElementById('readSummaryBtn');
        const summaryDiv = document.getElementById('summaryText');
        const summaryText = summaryDiv.innerText;

        if (!summaryText || summaryText.trim() === '') {
          alert('Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ ƒë·ªçc.');
          return;
        }

        const summaryTextCleaned = summaryText.replace(
          /\[\d{2}:\d{2}(?:[‚Äì-]\d{2}:\d{2})?\]/g,
          ''
        );

        if (audioPlayer && !audioPlayer.paused) {
          audioPlayer.pause();
          btn.innerHTML = 'üîä ƒê·ªçc T√≥m T·∫Øt';
          return;
        }

        if (audioPlayer && audioPlayer.paused && audioPlayer.src) {
          audioPlayer.play();
          btn.innerHTML = '‚è∏Ô∏è T·∫°m D·ª´ng ƒê·ªçc';
          return;
        }

        try {
          btn.disabled = true;
          btn.innerHTML = '‚è≥ ƒêang T·∫£i Audio...';

          const response = await fetch('/speak', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ text: summaryTextCleaned }),
          });

          if (!response.ok) {
            throw new Error(`Server Error: ${response.statusText}`);
          }

          const audioBlob = await response.blob();
          const audioUrl = URL.createObjectURL(audioBlob);

          if (audioPlayer) {
            audioPlayer.src = audioUrl;
          } else {
            audioPlayer = new Audio(audioUrl);
          }

          audioPlayer.onplay = () => {
            btn.disabled = false;
            btn.innerHTML = '‚è∏Ô∏è T·∫°m D·ª´ng ƒê·ªçc';
          };
          audioPlayer.onpause = audioPlayer.onended = () => {
            btn.innerHTML = 'üîä ƒê·ªçc T√≥m T·∫Øt';
            btn.disabled = false;
          };

          audioPlayer.play();
        } catch (error) {
          console.error('L·ªói khi ph√°t audio:', error);
          alert(
            'L·ªói: Kh√¥ng th·ªÉ nh·∫≠n audio t·ª´ m√°y ch·ªß. Vui l√≤ng ki·ªÉm tra console.'
          );
          btn.innerHTML = 'üîä ƒê·ªçc T√≥m T·∫Øt';
        } finally {
          if (audioPlayer && audioPlayer.paused) {
            btn.disabled = false;
          }
        }
      }

      document
        .getElementById('summaryForm')
        .addEventListener('submit', async function (e) {
          e.preventDefault();

          const url = document.getElementById('youtubeUrl').value;
          const loading = document.getElementById('loadingMessage');
          const results = document.getElementById('results');
          const summaryText = document.getElementById('summaryText');
          const errorDiv = document.getElementById('errorMessage');

          const submitBtn = document.getElementById('submitBtn');

          results.classList.add('hidden');
          errorDiv.classList.add('hidden');
          loading.classList.remove('hidden');
          submitBtn.disabled = true;

          const pendingMessages = getStatusMessage('PENDING', 'N/A');
          submitBtn.textContent = pendingMessages.button;
          loading.innerHTML = pendingMessages.loading;

          const POLLING_INTERVAL_MS = 10000;
          const MAX_TOTAL_WAIT_MS = 60 * 60 * 1000;
          let totalTimeWaited = 0;
          let jobPollingInterval = null;

          try {
            const initialResponse = await fetch('/summarize', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ youtubeUrl: url }),
            });

            if (!initialResponse.ok) {
              const errorData = await initialResponse.json();
              throw new Error(
                errorData.error || 'L·ªói kh·ªüi t·∫°o y√™u c·∫ßu t√≥m t·∫Øt.'
              );
            }

            const initialData = await initialResponse.json();
            const jobId = initialData.jobId;

            // C·∫≠p nh·∫≠t th√¥ng b√°o sau khi c√≥ Job ID
            const jobInitMessages = getStatusMessage('PENDING', jobId);
            submitBtn.textContent = jobInitMessages.button;
            loading.innerHTML = jobInitMessages.loading;

            await new Promise((resolve, reject) => {
              jobPollingInterval = setInterval(async () => {
                totalTimeWaited += POLLING_INTERVAL_MS;

                if (totalTimeWaited > MAX_TOTAL_WAIT_MS) {
                  clearInterval(jobPollingInterval);
                  return reject(
                    new Error(
                      'Y√™u c·∫ßu b·ªã h·ªßy: ƒê√£ v∆∞·ª£t qu√° th·ªùi gian ch·ªù t·ªëi ƒëa (1 gi·ªù).'
                    )
                  );
                }

                const statusResponse = await fetch(`/status/${jobId}`);
                if (!statusResponse.ok) {
                  clearInterval(jobPollingInterval);
                  const errorData = await statusResponse.json();
                  return reject(
                    new Error(
                      errorData.error ||
                        'Kh√¥ng th·ªÉ ki·ªÉm tra tr·∫°ng th√°i c√¥ng vi·ªác.'
                    )
                  );
                }

                const jobStatus = await statusResponse.json();

                // C·∫¨P NH·∫¨T th√¥ng b√°o chi ti·∫øt t·∫°i ƒë√¢y
                const currentMessages = getStatusMessage(
                  jobStatus.status,
                  jobId
                );
                submitBtn.textContent = currentMessages.button;
                loading.innerHTML = currentMessages.loading;

                if (jobStatus.status === 'COMPLETED') {
                  clearInterval(jobPollingInterval);
                  const summary = convertTimestampsToLinks(
                    jobStatus.result,
                    url
                  );
                  summaryText.innerHTML = marked.parse(summary);
                  results.classList.remove('hidden');
                  resolve();
                } else if (jobStatus.status === 'FAILED') {
                  clearInterval(jobPollingInterval);
                  return reject(
                    new Error(`X·ª≠ l√Ω th·∫•t b·∫°i: ${jobStatus.error}`)
                  );
                }

                console.log(
                  `Job ${jobId} Status: ${jobStatus.status} - ƒê√£ ch·ªù ${
                    totalTimeWaited / 1000
                  }s`
                );
              }, POLLING_INTERVAL_MS);
            });
          } catch (error) {
            errorDiv.textContent =
              'L·ªói h·ªá th·ªëng ho·∫∑c qu√° tr√¨nh x·ª≠ l√Ω: ' + error.message;
            errorDiv.classList.remove('hidden');
          } finally {
            if (jobPollingInterval) {
              clearInterval(jobPollingInterval);
            }
            loading.classList.add('hidden');
            submitBtn.disabled = false;
            submitBtn.textContent = 'T√≥m T·∫Øt';
          }
        });
    </script>
  </body>
</html>
